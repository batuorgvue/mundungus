/**
 * Generate TypeScript interface definitions from your Postgres schema
 * pg-to-ts is derived from PYST/schemats, which was a fork of SweetIQ/schemats.
 */

import {Options as ITFOptions, processString} from 'typescript-formatter';

import {loadDefaultOptions, Options} from './options';
import {PostgresDatabase, TableWithMetaData} from './schemaPostgres';
import {
  attachJoinTypes,
  generateEnumType,
  generateTableInterface,
  TableNames,
} from './typescript';

// eslint-disable-next-line @typescript-eslint/no-var-requires
// const pkgVersion = require("../package.json").version

const buildHeader = (
  db: PostgresDatabase,
  tables: TableWithMetaData[],
  schema: string | null,
  options: Options,
): string => {
  const commands = [
    'pg-to-ts',
    'generate',
    '-c',
    db.connectionString.replace(/:\/\/.*@/, '://username:password@'),
  ];
  if (options.camelCase) {
    commands.push('-C');
  }

  if (tables.length > 0) {
    tables.forEach(t => {
      commands.push('-t', t.tableName);
    });
  }
  if (schema) {
    commands.push('-s', schema);
  }

  return `
        /**
         * AUTO-GENERATED FILE - DO NOT EDIT!
         *
         * This file was automatically generated by pg-to-ts v.${1}
         * $ ${commands.join(' ')}
         *
         */

    `;
};

export const typescriptOfTable = async (
  db: PostgresDatabase,
  table: string,
  schema: string,
  options = loadDefaultOptions(),
) => {
  const tableTypes = await db.getTableTypes(table, schema, options);

  return generateTableInterface(table, tableTypes, schema, options);
};

export const typescriptOfSchema = async (
  dbIn: PostgresDatabase | string,
  tables: string[] = [],
  excludedTables: string[] = [],
  inSchema: string | null = null,
  userOptions?: Partial<Options>,
): Promise<string> => {
  const db = typeof dbIn === 'string' ? new PostgresDatabase(dbIn) : dbIn;
  const schema = inSchema ?? db.getDefaultSchema();

  const tablesWithMetaData = (await db.getSchemaTables(schema)).filter(
    t => excludedTables.indexOf(t.tableName) === -1,
  );

  const options = loadDefaultOptions(userOptions);

  const enumTypes = generateEnumType(await db.getEnumTypes(schema), options);
  const interfacePromises = tables.map(table =>
    typescriptOfTable(db, table, schema, options),
  );
  const interfaceTuples = await Promise.all(interfacePromises);
  const tablesToNames: Record<string, TableNames> = {};
  tables.forEach((table, i) => {
    tablesToNames[table] = interfaceTuples[i][1];
  });

  const interfaces = interfaceTuples
    .map(([ts]) => attachJoinTypes(ts, tablesToNames))
    .join('');
  const typesToImport = new Set<string>();
  for (const types of interfaceTuples.map(([, , types]) => types)) {
    types.forEach(typesToImport.add, typesToImport);
  }
  let importTs = '';
  if (options.jsonTypesFile && typesToImport.size) {
    const symbols = Array.from(typesToImport).join(', ');
    importTs = `import {${symbols}} from "${options.jsonTypesFile}";\n\n`;
  }

  const views = tablesWithMetaData.filter(t => t.isView).map(t => t.tableName);

  const viewNames = interfaceTuples
    .filter(([, name]) => views.includes(name.var))
    .map(([, name]) => name);
  const tableNames = interfaceTuples
    .filter(([, name]) => !views.includes(name.var))
    .map(([, name]) => name);

  const makeTypeMaps = (tableNames: TableNames[]) =>
    tableNames
      .map(
        names => `
    ${names.var}: {
      select: ${names.type};
      input: ${names.input};
    };`,
      )
      .join('');

  const tableTypeMaps = makeTypeMaps(tableNames);
  const viewTypeMaps = makeTypeMaps(viewNames);

  let output = '/* tslint:disable */\n/* eslint-disable */\n\n';
  if (options.writeHeader) {
    output += buildHeader(db, tablesWithMetaData, schema, options);
  }

  // TODO(danvk): This is a better type than unknown, but typescript-json-schema chokes on it.
  // type Json =
  // | string
  // | number
  // | boolean
  // | null
  // | { [property: string]: Json }
  // | Json[];

  output += importTs;
  output += `
  export type Json = unknown;
    `;

  output += enumTypes;
  output += interfaces;

  const tableMap = tableNames.map(names => names.var).join(',\n  ');
  const viewMap = viewNames.map(names => names.var).join(',\n  ');

  output += `

  export interface TableTypes {${tableTypeMaps}
  }

  export const tables = {
    ${tableMap},
  }
  
  
  `;

  output +=
    viewNames.length !== 0
      ? `

  export interface ViewTypes {${viewTypeMaps}
  }

  export const views = {
    ${viewMap},
  }
  
  
  `
      : '';

  const formatterOption: ITFOptions = {
    replace: false,
    verify: false,
    tsconfig: true,
    tslint: true,
    editorconfig: true,
    tsfmt: true,
    vscode: false,
    tsconfigFile: null,
    tslintFile: null,
    vscodeFile: null,
    tsfmtFile: null,
  };

  const processedResult = await processString(
    'schema.ts',
    output,
    formatterOption,
  );

  return processedResult.dest.replace(/ {4}/g, '  ');
};

export {Database} from './schemaInterfaces';
export {Options};
